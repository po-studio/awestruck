Feature Request:

- add new route to routes_handler.go that will GET a "synth" by name. GET /synths/:synthName for now, we can hardcode the synth name to be "liljedahl_abio_e" which lives in server/sc/src/human/liljedahl/liljedahl_abio_e.scd
- we should expect every synth to have params that it exposes. for example, with liljedahl_abio_e, we should expect to see params like:

  - dcy
  - bd
  - sd
  - gverbSize
  - gverbTail
  - gverbEarly

  they are defined in the { | <synthparam1>, <synthparam2>, ... | } block at the top of the synthdef file.

- in response to the GET route, we want to return an API response with the modifiable synth params as defined for this particular synth
- let's create a new endpoint in routes_handler.go that will behave much like the /offer endpoint, but it will be POST /synth/:synthName/sessions that will start the synth with its default params and create a new session...for now this session can come from the frontend as it does for the /offer endpoint (see the @client directory for the frontend code)
- (hitting that POST endpoint will start playing the synth in the browser via webrtc, just like happens with the /offer endpoint)
- now, we want to add a new route that will be POST /synth/:synthName/sessions/:sessionId/params that will update the params of the synth for this session as it is playing in realtime (pretty cool, eh?). the way this should work:

  - use gRPC / OSC or whatever protocol combination you suggest for rapid modifications of the running synth by using supercollider's "set" command. for the example synth liljedahl_abio_e, we should expect to see params set like the below:

  x.set(\dcy, 0.5); // Increase comb reverb decay for the drums
  x.set(\bd, 1.5); // Make the kick stronger
  x.set(\sd, 1.5); // Make snare quieter
  x.set(\gverbSize, 80, \gverbTail, 40); // Big pad reverb
  x.set(\padFadeTime, 60);  
  x.set(\ringzFadeTime, 180);

// 2) New parameters:
x.set(\padGain, 0.8); // Louder core pad
x.set(\pitGain, 0.8); // Boost pitched feedback
x.set(\fbSatur, 1.5); // More saturation on feedback
x.set(\swirlAmt, 1.0); // Turn off swirl (set 1.0 to turn it on)
x.set(\padLPfreq, 3000); // Darker pad
x.set(\padLPq, 0.5); // Increase resonance
x.set(\drumGain, 0.5); // Quieter overall drums
x.set(\drumLPfreq, 1000); // Very muffled drums
x.set(\metal, 0.5); // Extra-loud "metal" ringz component
x.set(\ringzNoiseLevel, 0.05); // Tiny bit of ringz noise
x.set(\eqNotchFreq, 4000, \eqNotchDB, -10); // Deeper notch

// 3) Pitch shift params for the feedback path
x.set(\pitchShift1Ratio, 0.4, \pitchShift1Pitch, 0.7);
x.set(\pitchShift2Ratio, 0.6, \pitchShift2Pitch, 1.5);

[we should not be able to call "x.free" on the synth]

- what we want is to support real-time control of a running synth that is being synthesized and streamed in realtime over the internet
